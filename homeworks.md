### Домашнее задание 1\. Обход файлов

1.  Разработайте класс <tt>Walk</tt>, осуществляющий подсчет хеш-сумм файлов.
    1.  Формат запуска

            java Walk <входной файл> <выходной файл>

    2.  Входной файл содержит список файлов, которые требуется обойти.
    3.  Выходной файл должен содержать по одной строке для каждого файла. Формат строки:

            <шестнадцатеричная хеш-сумма> <путь к файлу>

    4.  Для подсчета хеш-суммы используйте алгоритм [FNV](https://ru.wikipedia.org/wiki/FNV).
    5.  Если при чтении файла возникают ошибки, укажите в качестве его хеш-суммы <tt>00000000</tt>.
    6.  Кодировка входного и выходного файлов — UTF-8.
    7.  Размеры файлов могут превышать размер оперативной памяти.
    8.  Пример

        Входной файл

            java/info/kgeorgiy/java/advanced/walk/samples/1
            java/info/kgeorgiy/java/advanced/walk/samples/12
            java/info/kgeorgiy/java/advanced/walk/samples/123
            java/info/kgeorgiy/java/advanced/walk/samples/1234
            java/info/kgeorgiy/java/advanced/walk/samples/1
            java/info/kgeorgiy/java/advanced/walk/samples/binary
            java/info/kgeorgiy/java/advanced/walk/samples/no-such-file

        Выходной файл

            050c5d2e java/info/kgeorgiy/java/advanced/walk/samples/1
            2076af58 java/info/kgeorgiy/java/advanced/walk/samples/12
            72d607bb java/info/kgeorgiy/java/advanced/walk/samples/123
            81ee2b55 java/info/kgeorgiy/java/advanced/walk/samples/1234
            050c5d2e java/info/kgeorgiy/java/advanced/walk/samples/1
            8e8881c5 java/info/kgeorgiy/java/advanced/walk/samples/binary
            00000000 java/info/kgeorgiy/java/advanced/walk/samples/no-such-file

2.  Усложненная версия:
    1.  Разработайте класс <tt>RecursiveWalk</tt>, осуществляющий подсчет хеш-сумм файлов в директориях
    2.  Входной файл содержит список файлов и директорий, которые требуется обойти. Обход директорий осуществляется рекурсивно.
    3.  Пример

        Входной файл

            java/info/kgeorgiy/java/advanced/walk/samples/binary
            java/info/kgeorgiy/java/advanced/walk/samples

        Выходной файл

            8e8881c5 java/info/kgeorgiy/java/advanced/walk/samples/binary
            050c5d2e java/info/kgeorgiy/java/advanced/walk/samples/1
            2076af58 java/info/kgeorgiy/java/advanced/walk/samples/12
            72d607bb java/info/kgeorgiy/java/advanced/walk/samples/123
            81ee2b55 java/info/kgeorgiy/java/advanced/walk/samples/1234
            8e8881c5 java/info/kgeorgiy/java/advanced/walk/samples/binary

3.  При выполнении задания следует обратить внимание на:
    *   Дизайн и обработку исключений, диагностику ошибок.
    *   Программа должна корректно завершаться даже в случае ошибки.
    *   Корректная работа с вводом-выводом.
    *   Отсутствие утечки ресурсов.
4.  Требования к оформлению задания.
    *   Проверяется исходный код задания.
    *   Весь код должен находиться в пакете <tt>ru.ifmo.ctddev.фамилия.walk</tt>.

[Тесты к домашним заданиям](https://github.com/kgeorgiy/java-advanced-2017)

### Домашнее задание 2\. Множество на массиве

1.  Разработайте класс <tt>ArraySet</tt>, реализующие неизменяемое упорядоченное множество.
    *   Класс <tt>ArraySet</tt> должен реализовывать интерфейс <tt>SortedSet</tt> (упрощенная версия) или <tt>NavigableSet</tt> (усложненная версия).
    *   Все операции над множествами должны производиться с максимально возможной асимптотической эффективностью.
2.  При выполнении задания следует обратить внимание на:
    *   Применение стандартных коллекций.
    *   Избавления от boilerplate кода.

### Домашнее задание 3\. Implementor

1.  Реализуйте класс <tt>Implementor</tt>, который будет генерировать реализации классов и интерфейсов.
    *   Аргументы командной строки: полное имя класса/интерфейса, для которого требуется сгенерировать реализацию.
    *   В результате работы должен быть сгенерирован java-код класса с суффиксом <tt>Impl</tt>, расширяющий (реализующий) указанный класс (интерфейс).
    *   Сгенерированный класс должен компилироваться без ошибок.
    *   Сгенерированный класс не должен быть абстрактным.
    *   Методы сгенерированного класса должны игнорировать свои аргументы и возвращать значения по умолчанию.
2.  В задании выделяются три уровня сложности:
    *   _Простой_ — <tt>Implementor</tt> должен уметь реализовывать только интерфейсы (но не классы). Поддержка generics не требуется.
    *   _Сложный_ — <tt>Implementor</tt> должен уметь реализовывать и классы и интерфейсы. Поддержка generics не требуется.
    *   _Бонусный_ — <tt>Implementor</tt> должен уметь реализовывать generic-классы и интерфейсы. Сгенерированный код должен иметь корректные параметры типов и не порождать <tt>UncheckedWarning</tt>.

### Домашнее задание 4\. Jar Implementor

1.  Создайте <tt>.jar</tt>-файл, содержащий скомпилированный <tt>Implementor</tt> и сопутствующие классы.
    *   Созданный <tt>.jar</tt>-файл должен запускаться командой <tt>java -jar</tt>.
    *   Запускаемый <tt>.jar</tt>-файл должен принимать те же аргументы командной строки, что и класс <tt>Implementor</tt>.
2.  Модифицируйте <tt>Implemetor</tt> так, что бы при запуске с аргументами <tt>-jar имя-класса файл.jar</tt> он генерировал <tt>.jar</tt>-файл с реализацией соответствующего класса (интерфейса).
3.  Для проверки, кроме исходного кода так же должны быть предъявлены:
    *   скрипт для создания запускаемого <tt>.jar</tt>-файла, в том числе, исходный код манифеста;
    *   запускаемый <tt>.jar</tt>-файл.
4.  Данное домашнее задание сдается только вместе с предыдущим. Предыдущее домашнее задание отдельно сдать будет нельзя.

### Домашнее задание 5\. Javadoc

1.  Документируйте класс <tt>Implementor</tt> и сопутствующие классы с применением Javadoc.
    *   Должны быть документированы все классы и все члены классов, в том числе закрытые (<tt>private</tt>).
    *   Документация должна генерироваться без предупреждений.
    *   Сгенерированная документация должна содержать корректные ссылки на классы стандартной библиотеки.
2.  Для проверки, кроме исходного кода так же должны быть предъявлены:
    *   скрипт для генерации документации;
    *   сгенерированная документация.
3.  Данное домашнее задание сдается только вместе с предыдущим. Предыдущее домашнее задание отдельно сдать будет нельзя.

### Домашнее задание 6\. Итеративный параллелизм

1.  Реализуйте класс <tt>IterativeParallelism</tt>, который будет обрабатывать списки в несколько потоков.
2.  В _простом_ варианте должны быть реализованы следующие методы:
    *   <tt>minimum(threads, list, comparator)</tt> — первый минимум;
    *   <tt>maximum(threads, list, comparator)</tt> — первый максимум;
    *   <tt>all(threads, list, predicate)</tt> — проверка, что все элементы списка удовлетворяют [предикату](https://docs.oracle.com/javase/8/docs/api/java/util/function/Predicate.html);
    *   <tt>any(threads, list, predicate)</tt> — проверка, что существует элемент списка, удовлетворяющий [предикату](https://docs.oracle.com/javase/8/docs/api/java/util/function/Predicate.html).
3.  В _сложном_ варианте должны быть дополнительно реализованы следующие методы:
    *   <tt>filter(threads, list, predicate)</tt> — вернуть список, содержащий элементы удовлетворяющие [предикату](https://docs.oracle.com/javase/8/docs/api/java/util/function/Predicate.html);
    *   <tt>map(threads, list, function)</tt> — вернуть список, содержащий результаты применения [функции](https://docs.oracle.com/javase/8/docs/api/java/util/function/Function.html);
    *   <tt>join(threads, list)</tt> — конкатенация строковых представлений элементов списка.
4.  Во все функции передается параметр <tt>threads</tt> — сколько потоков надо использовать при вычислении. Вы можете рассчитывать, что число потоков не велико.
5.  Не следует рассчитывать на то, что переданные компараторы, предикаты и функции работают быстро.
6.  При выполнении задания нельзя использовать _Concurrency Utilities_.
7.  Рекомендуется подумать, какое отношение к заданию имеют [моноиды](https://en.wikipedia.org/wiki/Monoid).

### Домашнее задание 7\. Параллельный запуск

1.  Напишите класс <tt>ParallelMapperImpl</tt>, реализующий интерфейс <tt>ParallelMapper</tt>.

        public interface ParallelMapper extends AutoCloseable {
            <T, R> List<R> run(
                Function<? super T, ? extends R> f, 
                List<? extends T> args
            ) throws InterruptedException;

            @Override
            void close() throws InterruptedException;
        }

    *   Метод <tt>run</tt> должен параллельно вычислять функцию <tt>f</tt> на каждом из указанных аргументов (<tt>args</tt>).
    *   Метод <tt>close</tt> должен останавливать все рабочие потоки.
    *   Конструктор <tt>ParallelMapperImpl(int threads)</tt> создает <tt>threads</tt> рабочих потоков, которые могут быть использованы для распараллеливания.
    *   К одному <tt>ParallelMapperImpl</tt> могут одновременно обращаться несколько клиентов.
    *   Задания на исполнение должны накапливаться в очереди и обрабатываться в порядке поступления.
    *   В реализации не должно быть активных ожиданий.
2.  Модифицируйте касс <tt>IterativeParallelism</tt> так, чтобы он мог использовать <tt>ParallelMapper</tt>.
    *   Добавьте конструктор <tt>IterativeParallelism(ParallelMapper)</tt>
    *   Методы класса должны делить работу на <tt>threads</tt> фрагментов и исполнять их при помощи <tt>ParallelMapper</tt>.
    *   Должна быть возможность одновременного запуска и работы нескольких клиентов, использующих один <tt>ParallelMapper</tt>.
    *   При наличии <tt>ParallelMapper</tt> сам <tt>IterativeParallelism</tt> новые потоки создавать не должен.

### Домашнее задание 8\. Web Crawler

1.  Напишите потокобезопасный класс <tt>WebCrawler</tt>, который будет рекурсивно обходить сайты.
    1.  Класс <tt>WebCrawler</tt> должен иметь конструктор

            public WebCrawler(Downloader downloader, int downloaders, int extractors, int perHost)

        *   <tt>downloader</tt> позволяет скачивать страницы и извлекать из них ссылки;
        *   <tt>downloaders</tt> — максимальное число одновременно загружаемых страниц;
        *   <tt>extractors</tt> — максимальное число страниц, из которых извлекаются ссылки;
        *   <tt>perHost</tt> — максимальное число страниц, одновременно загружаемых c одного хоста. Для опредения хоста следует использовать метод <tt>getHost</tt> класса <tt>URLUtils</tt> из тестов.
    2.  Класс <tt>WebCrawler</tt> должен реализовывать интерфейс <tt>Crawler</tt>

            public interface Crawler extends AutoCloseable {
                List<String> download(String url, int depth) throws IOException;

                void close();
            }

        *   Метод <tt>download</tt> должен рекурсивно обходить страницы, начиная с указанного URL на указанную глубину и возвращать список загруженных страниц и файлов. Например, если глубина равна 1, то должна быть загружена только указанная страница. Если глубина равна 2, то указанная страница и те страницы и файлы, на которые она ссылается и так далее. Этот метод может вызываться параллельно в нескольких потоках.
        *   Загрузка и обработка страниц (извлечение ссылок) должна выполняться максимально параллельно, с учетом ограничений на число одновременно загружаемых страниц (в том числе с одного хоста) и страниц, с которых загружаются ссылки.
        *   Для распараллеливания разрешается создать до <tt>downloaders + extractors</tt> вспомогательных потоков.
        *   Загружать и/или извлекать ссылки из одной и той же страницы запрещается.
        *   Метод <tt>close</tt> должен завершать все вспомогательные потоки.
    3.  Для загрузки страниц должен применяться <tt>Downloader</tt>, передаваемый первым аргументом конструктора.

            public interface Downloader {
                public Document download(final String url) throws IOException;
            }

        *   Метод <tt>download</tt> загружает документ по его адресу ([URL](http://tools.ietf.org/html/rfc3986)).
        *   Документ позволяет получить ссылки по загруженной странице:

                public interface Document {
                    List<String> extractLinks() throws IOException;
                }

            Ссылки, возвращаемые документом являются абсолютными и имеют схему <tt>http</tt> или <tt>https</tt>.
    4.  Должен быть реализован метод <tt>main</tt>, позволяющий запустить обход из командной строки
        *   Командная строка

                WebCrawler url [downloads [extractors [perHost]]]

        *   Для загрузки страниц требуется использовать реализацию <tt>CachingDownloader</tt> из тестов.
2.  Версии задания
    1.  _Простая_ — можно не учитывать ограничения на число одновременных закачек с одного хоста <tt>(perHost >= downloaders)</tt>.
    2.  _Полная_ — требуется учитывать все ограничения.

### Домашнее задание 9\. HelloUDP

1.  Реализуйте клиент и сервер, взаимодействующие по UDP.
2.  Класс <tt>HelloUDPClient</tt> должен отправлять запросы на сервер, принимать результаты и выводить их на консоль.
    *   Аргументы командной строки:
        1.  имя или ip-адрес компьютера, на котором запущен сервер;
        2.  номер порта, на который отсылать запросы;
        3.  префикс запросов (строка);
        4.  число параллельных потоков запросов;
        5.  число запросов в каждом потоке.
    *   Запросы должны одновременно отсылаться в указанном числе потоков. Каждый поток должен ожидать обработки своего запроса и выводить сам запрос и результат его обработки на консоль. Если запрос не был обработан, требуется послать его заного.
    *   Запросы должны формироваться по схеме <tt><префикс запросов><номер потока>_<номер запроса в потоке></tt>.
3.  Класс <tt>HelloUDPServer</tt> должен принимать задания, отсылаемые классом <tt>HelloUDPClient</tt> и отвечать на них.
    *   Аргументы командной строки:
        1.  номер порта, по которому будут приниматься запросы;
        2.  число рабочих потоков, которые будут обрабатывать запросы.
    *   Ответом на запрос должно быть <tt>Hello, <текст запроса></tt>.
    *   Если сервер не успевает обрабатывать запросы, прием запросов может быть временно приостановлен.

### Домашнее задание 10\. Физические лица

1.  Добавьте к банковскому приложению возможность работы с физическими лицами.
    1.  У физического лица (<tt>Person</tt>) можно запросить имя, фамилию и номер паспорта.
    2.  Локальные физические лица (<tt>LocalPerson</tt>) должны передаваться при помощи механизма сериализации.
    3.  Удаленные физические лица (<tt>RemotePerson</tt>) должны передаваться при помощи удаленных объектов.
    4.  Должна быть возможность поиска физического лица по номеру паспорта, с выбором типа возвращаемого лица.
    5.  Должна быть возможность создания записи о физическом лице по его данным.
    6.  У физического лица может быть несколько счетов, к которым должен предоставляться доступ.
2.  Реализуйте приложение, демонстрирующее работу с физическим лицами.
    1.  Аргументы командной строки: имя, фамилия, номер паспорта физического лица, номер счета, изменение суммы счета.
    2.  Если информация об указанном физическом лице отсутствует, то оно должно быть добавлено. В противном случае - - должны быть проверены его данные.
    3.  Если у физического лица отсутствует счет с указанным номером, то он создается с нулевым балансом.
    4.  После обновления суммы счета, новый баланс должен выводиться на консоль.